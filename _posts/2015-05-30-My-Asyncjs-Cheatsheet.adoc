= My Async.js Cheatsheet
:hp-tags: english, tech, js

This cheatsheet's aim is to simplify the Aync.js library docs. However the complete docs can be found at https://github.com/caolan/async.

== About Async.js

Async is a utility module which provides straight-forward, powerful functions for working with asynchronous JavaScript. Although originally designed for use with Node.js and installable via npm install async, it can also be used directly in the browser.

=== async.each(arr, iterator, callback])

Applies the function iterator to each item in arr, in parallel. The iterator is called with an item from the list, and a callback for when it has finished. If the iterator passes an error to its callback, the main callback (for the each function) is immediately called with the error.

Note, that since this function applies iterator to each item in parallel, there is no guarantee that the iterator functions will complete in order.

*Arguments*

- arr: An array to iterate over.
- iterator(item, callback): A function to apply to each item in arr. The iterator is passed a callback(err) which must be called once it has completed. If no error has occurred, the callback should be run without arguments or with an explicit null argument. The array index is not passed to the iterator. If you need the index, use forEachOf.
- callback(err): A callback which is called when all iterator functions have finished, or an error occurs.


*Example*

```
// assuming openFiles is an array of file names
async.each(openFiles, function (file, callback) {

  // Perform operation on file here.
  console.log('Processing file ' + file);

  if( file.length > 32 ) {
      console.log('This file name is too long');
      callback('File name too long');
  } else {
      // Do work to process file here
      console.log('File processed');
      callback();
  }

}, function (err){
    // if any of the file processing produced an error, err would equal that error
    if(err) {
        // One of the iterations produced an error.
        // All processing will now stop.
        console.log('A file failed to process');
        console.dir(err);
    } else {
        console.log('All files have been processed successfully');
    }
});
```

== Asynchronous Control Flow

=== async.series(tasks, [callback])

Run the functions in the tasks array in series, *each one running once the previous function has completed*. If any functions in the series pass an error to its callback, no more functions are run, and callback is immediately called with the value of the error. Otherwise, callback receives an array of results when tasks have completed.

*Example*

```
async.series([
    function(callback){
        // do some stuff ...
        callback (null, 'one');
    },
    function(callback){
        // do some more stuff ...
        callback (null, 'two');
    }
],
// optional callback
function (err, results){
    // results is now equal to ['one', 'two']
});
```

=== async.parallel(tasks, [callback])

Run the tasks array of functions in parallel, *without waiting until the previous function has completed*. If any of the functions pass an error to its callback, the main callback is immediately called with the value of the error. Once the tasks have completed, the results are passed to the final callback as an array.

*Arguments*

- tasks: An array or object containing functions to run. Each function is passed a callback(err, result) which it must call on completion with an error err (which can be null) and an optional result value.
- callback(err, results): An optional callback to run once all the functions have completed. This function gets a results array (or object) containing all the result arguments passed to the task callbacks.

*Example*

```
async.parallel([
    function (callback){
        setTimeout(function(){
            callback(null, 'one');
        }, 200);
    },
    function (callback){
        setTimeout(function(){
            callback(null, 'two');
        }, 100);
    }
],
// optional callback
function (err, results){
    // the results array will equal ['one','two'] even though
    // the second function had a shorter timeout.
});
```

=== async.waterfall(tasks, [callback])

Runs the tasks array of functions in series, *each passing their results to the next in the array*. However, if any of the tasks pass an error to their own callback, the next function is not executed, and the main callback is immediately called with the error.

*Example*

```
async.waterfall([
    function (callback) {
        callback(null, 'one', 'two');
    },
    function (arg1, arg2, callback) {
      // arg1 now equals 'one' and arg2 now equals 'two'
        callback(null, 'three');
    },
    function (arg1, callback) {
        // arg1 now equals 'three'
        callback(null, 'done');
    }
], function (err, result) {
    // result now equals 'done'
});
```